//#define BUILDING_NODE_EXTENSION

#include <signal.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include "i2c-dev.h"
#include <fcntl.h>
#include "8x8font.h"
#include <string.h>
#include <math.h>
#include <unistd.h>
#include <cstdio>
#include <node.h>

using namespace v8;
using namespace std;

__u16 block[I2C_SMBUS_BLOCK_MAX];

int  reverse(int v);
void stampa(int rows[]);
void begin(int i2cbus, int address, int daddress);
void write(char *word);
void exit();

//global variables used for matrix
int  file;
int  VELOCITY = 1;
char *COLOR = (char*)"all";
bool REVERSE=false;
char *WORDS = (char*)"NON HAI IMPOSTATO NESSUN TESTO...";

int reverse(int v)
{
	int c = 0;
	int rev = 0;
	int inv = 7;
	for(int i = 0;i < 8; i++)
	{
		if(!REVERSE) {
			c = (v >> i) & 1;
			if(c)
			{
				rev = rev + pow(2, inv);
			}
			inv--;
		}
		if(REVERSE) {
			c = (v >> i) & 1;
			if(!c)
			{
				rev = rev + pow(2, inv);
			}
			inv--;
		}
	}
	return rev;
}

void stampa(int rows[])
{
	int verticalPos;
	int value;
	for (int a = 0; a < 8; a++) //loop parte nascosta
	{
		for (int n = 0; n < 8; n++) //loop parte visibile
		{
			verticalPos = 0;
			rows[n] >>= 1;		//sposto a sx la parte visibile dei caratteri di un bit

			for (int i = 7; i > -1; i--) //stampo le righe dal basso verso l'alto
			{
				value = rows[verticalPos];

				verticalPos++;
				if(COLOR[0] == 'a')
				{
					i2c_smbus_write_byte_data(file, i*2, (__u8)(value));
					i2c_smbus_write_byte_data(file, i*2+1, (__u8)(value));
				}
				if(COLOR[0] == 'r')
				{
					i2c_smbus_write_byte_data(file, i*2+1, (__u8)(value));
					i2c_smbus_write_byte_data(file, i*2, (0)); //just to havesame time
				}
				if(COLOR[0] == 'g')
				{
					i2c_smbus_write_byte_data(file, i*2, (__u8)(value));
					i2c_smbus_write_byte_data(file, i*2+1, (0)); //just to have same time
				}		
			}
		}
//		for (int i = 0; i < VELOCITY; i++)
//		{
			//DELAY
//		}
	}
}

//----------------------------------------------------------------

void begin(int i2cbus, int address, int daddress)
{
	i2cbus   = 1;
	address  = 112;
	daddress = 0;
	char filename[20];

	//Startup the matrix
	sprintf(filename, "/dev/i2c-%d", i2cbus);
	file = open(filename, O_RDWR);
	if (file < 0)
		{
			if (errno == ENOENT) 
		{
			fprintf(stderr, "Error: Could not open file /dev/i2c-%d: %s\n", i2cbus, strerror(ENOENT));
		}
		else 
		{
			fprintf(stderr, "Error: Could not open file `%s': %s\n", filename, strerror(errno));
			if (errno == EACCES)
				fprintf(stderr, "Run as root?\n");
		}
	}

	if (ioctl(file, I2C_SLAVE, address) < 0) 
	{
		fprintf(stderr, "Error: Could not set address to 0x%02x: %s\n", address, strerror(errno));
		//return -errno;
	}


	int res = i2c_smbus_write_byte(file, daddress);
	printf("%d",res);
	if (res < 0) {
		fprintf(stderr, "Warning - write failed, filename=%s, daddress=%d\n", filename, daddress);
	}

	daddress = 0x21; // Start oscillator (page 10)
	printf("writing: 0x%02x\n", daddress);
	res = i2c_smbus_write_byte(file, daddress);

	daddress = 0x81; // Display on, blinking off (page 11)
	printf("writing: 0x%02x\n", daddress);
	res = i2c_smbus_write_byte(file, daddress);

	daddress = 0xE7; // Full brightness (page 15)
	printf("Full brightness writing: 0x%02x\n", daddress);
	res = i2c_smbus_write_byte(file, daddress);

	daddress = 0x00; // Start writing to adress 0 (page 13)
	printf("Start writing to address 0 writing: 0x%02x\n", daddress);
	res = i2c_smbus_write_byte(file, daddress);
}//begin

void write(char *word)
{
	const short unsigned int *arr;
	int val;
	char *str = word;

	char valChar = *(word);

	arr = &FONT8x8[valChar-31][7];

	int rows[8];

	for (int a = 0; a < 8; a++)
	{
		val = reverse(*(arr--));
		val = val * 256;
		rows[a] = val;
	}

	while(true)
	{
		stampa(rows);

		//leggo il prossimo carattere e fillo l'array
		char valCharNext = *(str++ + 1); //+1 sta per il carattere succesivo al primo

		if(valCharNext == '\0') break;   //interrompo se finito stringa

		arr = &FONT8x8[valCharNext-31][7];

		for (int a = 0; a < 8; a++)
		{
			val = reverse(*(arr--));
			val = val * 256;							
			rows[a] += val;
		}
	}
	//usleep(VELOCITY);
}//write

void exit()
{
	int daddress = 0x20; // Stop oscillator (page 10)
	printf("writing: 0x%02x\n", daddress);
	int res = i2c_smbus_write_byte(file, daddress);

	daddress = 0x80; // Stop led (page 10)
	printf("writing: 0x%02x\n", daddress);
	res = i2c_smbus_write_byte(file, daddress);
	printf("%d",res);
	
	close(file);
	exit(0);
}//exit

//--------------- JAVASCRIPT EXPORT --------------------------

Handle<Value> _begin(const Arguments& args) {
	HandleScope scope;

	if (args.Length() < 3) {
		ThrowException(Exception::TypeError(String::New("Wrong number of arguments")));
		return scope.Close(Undefined());
	}

	if (!args[0]->IsNumber() || !args[1]->IsNumber() || !args[2]->IsNumber())
	{
		ThrowException(Exception::TypeError(String::New("Wrong arguments")));
		return scope.Close(Undefined());
	}

	// get the param
	Local<Integer> i2cbus = args[0]->ToInteger();
	Local<Integer> address = args[1]->ToInteger();
	Local<Integer> daddress = args[2]->ToInteger();

	begin(i2cbus->Value(), address->Value(), daddress->Value());

	return String::New("end of begin method");
}

Handle<Value> _write(const Arguments& args) {
	HandleScope scope;

	if (args.Length() < 4) {
		ThrowException(Exception::TypeError(String::New("Wrong number of arguments")));
		return scope.Close(Undefined());
	}

	if (!args[0]->IsNumber() || !args[1]->IsString() || !args[2]->IsBoolean() || !args[3]->IsString()) {
		ThrowException(Exception::TypeError(String::New("Wrong arguments")));
		return scope.Close(Undefined());
	}

	// get the param
	Local<Integer> integer = args[0]->ToInteger(); VELOCITY = integer->Value();
    String::Utf8Value color(args[1]->ToString());  COLOR = color.operator*();	
												   REVERSE = args[2]->ToBoolean()->Value();
	String::Utf8Value words(args[3]->ToString());  WORDS = words.operator*();

	write(WORDS);

	return String::New(WORDS);
}

Handle<Value> _exit(const Arguments& args) {
	exit();
	return String::New("Exit");
}

//----------------------------------- INIT -----------------------------------------------

void Init(Handle<Object> exports) {
	exports->Set(String::NewSymbol("begin"),
		FunctionTemplate::New(_begin)->GetFunction());
	
	exports->Set(String::NewSymbol("write"),
		FunctionTemplate::New(_write)->GetFunction());
	
	exports->Set(String::NewSymbol("exit"),
		FunctionTemplate::New(_exit)->GetFunction());
}

NODE_MODULE(addon, Init);