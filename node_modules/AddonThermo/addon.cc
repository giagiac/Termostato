// Access from ARM Running Linux

#define BCM2708_PERI_BASE        0x20000000
#define GPIO_BASE                (BCM2708_PERI_BASE + 0x200000) /* GPIO controller */

#include <stdio.h>
#include <string>
#include <stdlib.h>
#include <dirent.h>
#include <fcntl.h>
#include <assert.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <bcm2835.h>
#include <unistd.h>
#include <math.h>

#define MAXTIMINGS 100

//#define DEBUG


#define DHT11 11
#define DHT22 22
#define AM2302 22


#define BUILDING_NODE_EXTENSION
#include <node.h>

using namespace v8;
using namespace std;

void readDHT(int type, int pin);

float temp = 0, umid = 0;
bool isOk = false;

void readDHT(int type, int pin) {
	int counter = 0;
	int laststate = HIGH;
	int j=0;

	int bits[250], data[100];
	int bitidx = 0;

	//bcm2835_init();
	// Set GPIO pin to output
	bcm2835_gpio_fsel(pin, BCM2835_GPIO_FSEL_OUTP);


	bcm2835_gpio_write(pin, HIGH);
	usleep(500000);  // 500 ms
	bcm2835_gpio_write(pin, LOW);
	usleep(20000);

	bcm2835_gpio_fsel(pin, BCM2835_GPIO_FSEL_INPT);

	data[0] = data[1] = data[2] = data[3] = data[4] = 0;


	// wait for pin to drop?
	while (bcm2835_gpio_lev(pin) == 1) {
		usleep(1);
	}


	// read data!
	for (int i=0; i< MAXTIMINGS; i++) {
		counter = 0;
		while ( bcm2835_gpio_lev(pin) == laststate) {
			counter++;
			//nanosleep(1);		// overclocking might change this?
			if (counter == 1000)
				break;
		}
		laststate = bcm2835_gpio_lev(pin);
		if (counter == 1000) break;
		bits[bitidx++] = counter;


		if ((i>3) && (i%2 == 0)) {
			// shove each bit into the storage bytes
			data[j/8] <<= 1;
			if (counter > 200)
				data[j/8] |= 1;
			j++;
		}
	}

	//printf("Data (%d): 0x%x 0x%x 0x%x 0x%x 0x%x\n", j, data[0], data[1], data[2], data[3], data[4]);

	if ((j >= 39) && (data[4] == ((data[0] + data[1] + data[2] + data[3]) & 0xFF)) ) {
			//cicleCount = 0;
			// yay!
			/*if (type == DHT11)
			{
				temp = data[2];
				umid =  data[0];
			}*/
			//if (type == DHT22) 
			{
				float f, h;
				h = data[0] * 256 + data[1];
				h /= 10;


				f = (data[2] & 0x7F)* 256 + data[3];
				f /= 10.0;
				if (data[2] & 0x80)  f *= -1;
				
				temp=f;
				umid = h;
				isOk = true;
			}
	}
}

Handle<Value> ReadTemperatureUmidity(const Arguments& args) {
	HandleScope scope;

	if (args.Length() < 2) {
		ThrowException(Exception::TypeError(String::New("Wrong number of arguments")));
		return scope.Close(Undefined());
	}

	if (!args[0]->IsNumber() || !args[1]->IsNumber()) {
		ThrowException(Exception::TypeError(String::New("Wrong arguments")));
		return scope.Close(Undefined());
	}

	int dhtpin = args[0]->ToInteger()->Value();
	int type = args[1]->ToInteger()->Value(); // 11 or 22 in base al tipo di sensore

	isOk = false;
	
	for (int i = 0; i < 4; i++)
	{
		readDHT(dhtpin, type);
		if (isOk) break;
		sleep(1);
	}

	Local<Object> obj = Object::New();
	//temp = ceilf(temp * 100) / 100;
	//umid = ceilf(umid * 100) / 100;
	obj->Set(String::NewSymbol("temperatura"), (Number::New(temp))->ToString());
	obj->Set(String::NewSymbol("umidita"), (Number::New(umid))->ToString());


	return scope.Close(obj);
}

Handle<Value> begin(const Arguments& args) {
	HandleScope scope;
	bcm2835_init();
	return scope.Close(String::New("DHT Sensor init"));
}


void Init(Handle<Object> exports, Handle<Object> module) {
	exports->Set(String::NewSymbol("begin"),
		FunctionTemplate::New(begin)->GetFunction());
	exports->Set(String::NewSymbol("ReadTemperatureUmidity"),
		FunctionTemplate::New(ReadTemperatureUmidity)->GetFunction());
}

NODE_MODULE(addon, Init);
